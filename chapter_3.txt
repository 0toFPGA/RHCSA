File Hierarchy system breakdown

/ = root directory
/boot = Contains all files needed to boot linux
/dev = Contains device files that are used for accessing physical devices, essential during boot
/etc = contains configuration files used by programs and services
/home = used for local user home directories
/media,/mnt = used for mounting devices in the file system tree
/opt = used for optional packages
/proc = used by the proc file system... this gives access to kernel information
/root = the home directory of the root user
/run = May be used for data by services like NFS, FTP, HTTP
/sys = Used as an interface to different hardware devices that are managed by the Kernel and associated processes
/tmp = contains temporary files that may be deleted without any warning during boot
/usr = Contains subdirectories with program files, libraries for these program files, and documentation about them
/var = Contains files that may change in size dynamically, such as log files, mail boxes and spool files

a mount = is a connection between a device and a directory
The linux file system is presented as one hierarchy with the root directory (/) being the starting point
    This can be distibuted over different devices and even computer systems that are mounted into the root directory

Mounting devices makes it possible to organize the LFS in a flexible way.
    There are several disadvantages to storing all the files in just one file system, which gives several good reasons to work with multiple mounts
        1/ High activity in one area may fill up the entire file system, which will negatively impact services running on the server
        2/ If all files are on the same device, it is difficult to secure access and distinguish between different areas of the file system.
            Good practice seems to be mounting on a seperate file system and adding mount options to meet specific security needs.
        3/ If a one-device file system is completely filled, it may be difficult to make additional storage space avialable

Learn how to avoid the pitfalls by organizing LFS in different devices (and even shares on other computers), such as disk partitions and logical volumes, and mount these devices into the FSH.
    Configuring a device with a dedicated mount, you are able to use dpecific mount options that can restrict the access to the device.
        /boot = often mounted on another device because it requires extra information your computer needs during boot
                    linux cannot boot by default, kernel and associated files need to be stored seperatly on a /boot device
        /boot/EFI = if a system uses Exensible Firmware interface (EFI) a mount is required to give access to files at the earliest stages of boot procedure
        /var = typically on a dedicated device because it grows in a dynamic and uncontrolled way.
                    It is just to make sure the device does not get filled up.
        /home = on a dedicated device for security reasons. On a dedicated device you can mount it with specific options such as "noexec and nodev"
                    noexec = a mount option in Linux that prevents the execution of any binaries from the specified filesystem or directory
                    nodev = a mount option that prevents the interpretation of character or block special devices on a mounted filesystem
        /usr = contains operating file system files only, normal users do not need write access to this.
    OTHER servers can have different security measures that have other directories that are mounted on dedicated partitions or volumes.

mount and df commands
mount= is a dump of a lot of infromation that gives an overview of all mounted devices
df -Th = shows the mounted disks by using flags (-T= filesystem type and -h = summarizes it in a human readable way)
    df -Th is shown in 7 columns
        filesystem: The name of the device that interacts with the disk device that is used. The real devices in the output start with /dev
            There are also tmpfs, these are kernel devices that are used to create a temporary file system on RAM
        type: the type of filesystem used
        size: the size of the file used
        used: the amount of disk space the device has used
        avial: The amount of unused disk space
        Use%: the % of the device that is currently in use
        Mounted on: the dir the device is currently mounted on.

Managing files
need to comfortable with the following
Working with wildcards
Managing and working with directories
working with absolute and relative pathnames
listing file and directories
copying files and directories
moving files and directories
deleting files and directories

KEY TOPIC
    * = Refers to an unlimited number of characters. ls *, for instance, shows all files in the current dir (except those files that begin with a dot(.))
    ? = Used to refer to one specific character that can be any character. ls c?t would match cat as well as cut
    [auo] = Refers to one character that may be selected from the range that is specified between the square brackets. ls c[auo]t could match cat, cut, and cot.

directories are also referred to as folders.

KEY TOPIC
    absolute filename (or absolute pathname)= is a complete pathe reference to a file or directory you want to work with. this pathname starts with the root directory, followed by the subdirectories leading up to the actual filename.
        No matter your current directory absolute filenames will always work.
            EXAMPLE: /home/tommy/shell_script.log

    relative filename = is a relative to the current directory shown with the pwd command. It contains only the elements that are required to get from the current directory up to the item you need.'
        if you current directory is /home (shown by pwd). When you refer to the relative filename tommy/shell_script.log you are referring to the absolute filename /home/tommy/shell_script.log
        When working with relative filenames it is sometimes helpful to move up a level.
            EXAMPLE: You want to copy the file /home/tommy/shell_script.log to /home/tommy. A few solutions would work.
            1. cp /home/tommy/shell_script.log /home/tommy. this command uses absolute pathnames this will always work.
            2. (make sure your current directory is /home) cp tommy/shell_script.log tommy. you are using relative filenames here and that is why there is not a leading /. There is a risk if the directory tommy does not exist it will
                will create a file tommy. Use cp tommy/shell_script.log tommy/ to ensure that if the directory doesn't exist it will generate an error message.
            3. If the current directory is /home/tommy you can also use cp shell_script.log ../tommy
                what this command does is it copies the file up a level (you would be in the /home directory and from there it will look for the /tommy directory.)

